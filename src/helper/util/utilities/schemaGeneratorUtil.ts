#!/usr/bin/env node
/* PlayQ OpenAPI (OAS 3.1) -> schema TS files generator */

import fs from "node:fs";
import path from "node:path";

type OpenApiDoc = {
  openapi: string;
  components?: {
    schemas?: Record<string, any>;
  };
};

type Args = {
  input?: string;
  url?: string;
  outDir: string;
  prefix: string;
  indexFile: string;
};

function parseArgs(argv: string[]): Args {
  const args: Args = {
    outDir: "resources/schemas",
    prefix: "", // optional export prefix e.g. "Api"
    indexFile: "index.ts",
  };

  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    const v = argv[i + 1];

    if (a === "--input" && v) { args.input = v; i++; continue; }
    if (a === "--url" && v) { args.url = v; i++; continue; }
    if (a === "--outDir" && v) { args.outDir = v; i++; continue; }
    if (a === "--prefix" && v) { args.prefix = v; i++; continue; }
    if (a === "--indexFile" && v) { args.indexFile = v; i++; continue; }
  }

  if (!args.input && !args.url) {
    throw new Error(`Provide either --input <path-to-openapi.json> OR --url <openapi-json-url>`);
  }
  if (args.input && args.url) {
    throw new Error(`Use only one of --input or --url (not both).`);
  }
  return args;
}

async function loadOpenApi(args: Args): Promise<OpenApiDoc> {
  if (args.input) {
    const p = path.resolve(args.input);
    const raw = fs.readFileSync(p, "utf8");
    return JSON.parse(raw);
  }

  // URL
  const res = await fetch(args.url!, {
    headers: { Accept: "application/json" },
  });
  if (!res.ok) {
    throw new Error(`Failed to fetch OpenAPI JSON from ${args.url}. HTTP ${res.status}`);
  }
  return (await res.json()) as OpenApiDoc;
}

function safeIdent(name: string): string {
  // Make a valid TS identifier-ish name (keeps underscores)
  const cleaned = name.replace(/[^a-zA-Z0-9_]/g, "_");
  // Avoid leading digit
  if (/^\d/.test(cleaned)) return "_" + cleaned;
  return cleaned;
}

function exportNameFor(schemaName: string, prefix: string): string {
  // AgentVersion -> AgentVersionSchema, optional prefix -> ApiAgentVersionSchema
  const base = `${schemaName}Schema`;
  return prefix ? `${prefix}${base}` : base;
}

function ensureOutDir(outDir: string) {
  fs.mkdirSync(outDir, { recursive: true });
}

function writeSchemaFile(outDir: string, schemaKey: string, exportName: string, schema: any, openapiVersion: string) {
  const fileName = `${schemaKey}.schema.ts`;
  const fullPath = path.join(outDir, fileName);

  const content =
    `/* Auto-generated by PlayQ schema generator - OpenAPI ${openapiVersion} */\n` +
    `/* Source schema: #/components/schemas/${schemaKey} */\n\n` +
    `export const ${exportName} = ${JSON.stringify(schema, null, 2)} as const;\n`;

  fs.writeFileSync(fullPath, content, "utf8");
}

function writeIndexFile(outDir: string, indexFile: string, entries: Array<{ schemaKey: string; exportName: string }>) {
  const fullPath = path.join(outDir, indexFile);
  const lines = entries
    .sort((a, b) => a.schemaKey.localeCompare(b.schemaKey))
    .map(e => `export { ${e.exportName} } from "./${e.schemaKey}.schema";`);

  fs.writeFileSync(fullPath, lines.join("\n") + "\n", "utf8");
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const doc = await loadOpenApi(args);

  if (!doc.openapi?.startsWith("3.1")) {
    // still might work, but you said OAS 3.1 and this generator assumes that
    console.warn(`⚠️ OpenAPI version is "${doc.openapi}". Generator is optimised for 3.1.x.`);
  }

  const schemas = doc.components?.schemas ?? {};
  const schemaKeys = Object.keys(schemas);
  if (!schemaKeys.length) {
    throw new Error(`No components.schemas found in the OpenAPI document.`);
  }

  const outDir = path.resolve(args.outDir);
  ensureOutDir(outDir);

  const indexEntries: Array<{ schemaKey: string; exportName: string }> = [];

  for (const rawKey of schemaKeys) {
    const schemaKey = safeIdent(rawKey);
    const exportName = exportNameFor(schemaKey, args.prefix);
    const schema = schemas[rawKey];

    writeSchemaFile(outDir, schemaKey, exportName, schema, doc.openapi);
    indexEntries.push({ schemaKey, exportName });
  }

  writeIndexFile(outDir, args.indexFile, indexEntries);

  console.log(`✅ Generated ${schemaKeys.length} schemas into: ${outDir}`);
  console.log(`✅ Barrel export: ${path.join(outDir, args.indexFile)}`);
}

main().catch(err => {
  console.error(`❌ ${err instanceof Error ? err.message : String(err)}`);
  process.exit(1);
});